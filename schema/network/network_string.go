// Code generated by "enumer --values --type=Network --linecomment --output network_string.go --json --yaml --sql"; DO NOT EDIT.

package network

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

const _NetworkName = "unknownactivitypubarbitrumarweaveavaxbasebinance-smart-chainbitcoincrossbellethereumfarcastergnosislineanearoptimismpolygonrsssavmvslx-layer"

var _NetworkIndex = [...]uint8{0, 7, 18, 26, 33, 37, 41, 60, 67, 76, 84, 93, 99, 104, 108, 116, 123, 126, 130, 133, 140}

const _NetworkLowerName = "unknownactivitypubarbitrumarweaveavaxbasebinance-smart-chainbitcoincrossbellethereumfarcastergnosislineanearoptimismpolygonrsssavmvslx-layer"

func (i Network) String() string {
	if i >= Network(len(_NetworkIndex)-1) {
		return fmt.Sprintf("Network(%d)", i)
	}
	return _NetworkName[_NetworkIndex[i]:_NetworkIndex[i+1]]
}

func (Network) Values() []string {
	return NetworkStrings()
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NetworkNoOp() {
	var x [1]struct{}
	_ = x[Unknown-(0)]
	_ = x[ActivityPub-(1)]
	_ = x[Arbitrum-(2)]
	_ = x[Arweave-(3)]
	_ = x[Avalanche-(4)]
	_ = x[Base-(5)]
	_ = x[BinanceSmartChain-(6)]
	_ = x[Bitcoin-(7)]
	_ = x[Crossbell-(8)]
	_ = x[Ethereum-(9)]
	_ = x[Farcaster-(10)]
	_ = x[Gnosis-(11)]
	_ = x[Linea-(12)]
	_ = x[Near-(13)]
	_ = x[Optimism-(14)]
	_ = x[Polygon-(15)]
	_ = x[RSS-(16)]
	_ = x[SatoshiVM-(17)]
	_ = x[VSL-(18)]
	_ = x[XLayer-(19)]
}

var _NetworkValues = []Network{Unknown, ActivityPub, Arbitrum, Arweave, Avalanche, Base, BinanceSmartChain, Bitcoin, Crossbell, Ethereum, Farcaster, Gnosis, Linea, Near, Optimism, Polygon, RSS, SatoshiVM, VSL, XLayer}

var _NetworkNameToValueMap = map[string]Network{
	_NetworkName[0:7]:          Unknown,
	_NetworkLowerName[0:7]:     Unknown,
	_NetworkName[7:18]:         ActivityPub,
	_NetworkLowerName[7:18]:    ActivityPub,
	_NetworkName[18:26]:        Arbitrum,
	_NetworkLowerName[18:26]:   Arbitrum,
	_NetworkName[26:33]:        Arweave,
	_NetworkLowerName[26:33]:   Arweave,
	_NetworkName[33:37]:        Avalanche,
	_NetworkLowerName[33:37]:   Avalanche,
	_NetworkName[37:41]:        Base,
	_NetworkLowerName[37:41]:   Base,
	_NetworkName[41:60]:        BinanceSmartChain,
	_NetworkLowerName[41:60]:   BinanceSmartChain,
	_NetworkName[60:67]:        Bitcoin,
	_NetworkLowerName[60:67]:   Bitcoin,
	_NetworkName[67:76]:        Crossbell,
	_NetworkLowerName[67:76]:   Crossbell,
	_NetworkName[76:84]:        Ethereum,
	_NetworkLowerName[76:84]:   Ethereum,
	_NetworkName[84:93]:        Farcaster,
	_NetworkLowerName[84:93]:   Farcaster,
	_NetworkName[93:99]:        Gnosis,
	_NetworkLowerName[93:99]:   Gnosis,
	_NetworkName[99:104]:       Linea,
	_NetworkLowerName[99:104]:  Linea,
	_NetworkName[104:108]:      Near,
	_NetworkLowerName[104:108]: Near,
	_NetworkName[108:116]:      Optimism,
	_NetworkLowerName[108:116]: Optimism,
	_NetworkName[116:123]:      Polygon,
	_NetworkLowerName[116:123]: Polygon,
	_NetworkName[123:126]:      RSS,
	_NetworkLowerName[123:126]: RSS,
	_NetworkName[126:130]:      SatoshiVM,
	_NetworkLowerName[126:130]: SatoshiVM,
	_NetworkName[130:133]:      VSL,
	_NetworkLowerName[130:133]: VSL,
	_NetworkName[133:140]:      XLayer,
	_NetworkLowerName[133:140]: XLayer,
}

var _NetworkNames = []string{
	_NetworkName[0:7],
	_NetworkName[7:18],
	_NetworkName[18:26],
	_NetworkName[26:33],
	_NetworkName[33:37],
	_NetworkName[37:41],
	_NetworkName[41:60],
	_NetworkName[60:67],
	_NetworkName[67:76],
	_NetworkName[76:84],
	_NetworkName[84:93],
	_NetworkName[93:99],
	_NetworkName[99:104],
	_NetworkName[104:108],
	_NetworkName[108:116],
	_NetworkName[116:123],
	_NetworkName[123:126],
	_NetworkName[126:130],
	_NetworkName[130:133],
	_NetworkName[133:140],
}

// NetworkString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NetworkString(s string) (Network, error) {
	if val, ok := _NetworkNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NetworkNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Network values", s)
}

// NetworkValues returns all values of the enum
func NetworkValues() []Network {
	return _NetworkValues
}

// NetworkStrings returns a slice of all String values of the enum
func NetworkStrings() []string {
	strs := make([]string, len(_NetworkNames))
	copy(strs, _NetworkNames)
	return strs
}

// IsANetwork returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Network) IsANetwork() bool {
	for _, v := range _NetworkValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Network
func (i Network) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Network
func (i *Network) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Network should be a string, got %s", data)
	}

	var err error
	*i, err = NetworkString(s)
	return err
}

// MarshalYAML implements a YAML Marshaler for Network
func (i Network) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Network
func (i *Network) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = NetworkString(s)
	return err
}

func (i Network) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Network) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Network: %[1]T(%[1]v)", value)
	}

	val, err := NetworkString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
